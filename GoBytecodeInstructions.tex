\documentclass[12pt]{article}


%\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage[usenames, dvipsnames]{xcolor}
\definecolor{code}{RGB}{220,220,220}

\usepackage{blindtext}
\usepackage{scrextend}

\begin{document}
	\tableofcontents
	\newpage

	\section{int64}
		\begin{itemize}
			\item i64add
			\item i64sub
			\item i64mul
			\item i64div
			\item i64rem
			\\ \hrule
			\item i64and
			\item i64or
			\item i64xor
			\item i64clear
			\item i64shl (requires unsigned right operand)
			\item i64shr (required unisgned right operand)
			\\ \hrule
			\item i64neg (negation)
			\item i64comp (bitwise complement)
			\\ \hrule
			\item if\_i64eq
			\item if\_i64ne
			\item if\_i64lt
			\item if\_i64le
			\item if\_i64gt
			\item if\_i64ge
			\\ \hrule
			\item i64tof64
			\item i64toa
		\end{itemize}
		\newpage
		\subsection*{i64add}
			\addcontentsline{toc}{subsection}{i64add} 
			
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Add two int64s
				\item [\textbf{Format}] \fbox{\textit{i64add}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is pushed onto the stack. \\ \\
				The result is the 64 low-order bits in twos-complement format. 
				Overflow may occur as a result of this operation. Despite the fact that overflow can occur, \textit{i64add} never throws a runtime exception. 			\end{labeling}
			
		\newpage
		
		\subsection*{i64sub}
			\addcontentsline{toc}{subsection}{i64sub}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Subtract two int64s
				\item [\textbf{Format}] \fbox{\textit{i64sub}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is \textit{value1} - \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
				The result is the 64 low-order bits int twos-complement format. 
				Overflow may occur as a result of this operation. Despite the fact that overflow can occur, \textit{i64sub} never throws a runtime exception. 			\end{labeling}		
			
		\newpage
		\subsection*{i64mul}
			\addcontentsline{toc}{subsection}{i64mul}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Multiply two int64s
				\item [\textbf{Format}] \fbox{\textit{i64mul}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is \textit{value1} * \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
				The result is the 64 low-order bits int twos-complement format. 
				Overflow may occur as a result of this operation. Despite the fact that overflow can occur, \textit{i64mul} never throws a runtime exception. 			\end{labeling}		
				
		\newpage
		\subsection*{i64div}
			\addcontentsline{toc}{subsection}{i64div}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Divide two int64s
				\item [\textbf{Format}] \fbox{\textit{i64div}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is \textit{value1} / \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
				\textit{i64div} performs integer division, with \textit{result} truncated towards 0. \\ \\
				 If the dividend x is the most negative value for int64, the quotient q = x / -1 is equal to x.
				 \item [\textbf{Exception}] A run-time exception occurs when the divisor, \textit{value2}, is 0. 
			\end{labeling}		
			
		\newpage
		\subsection*{i64rem}
			\addcontentsline{toc}{subsection}{i64mod}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Remainder after division of two int64s
				\item [\textbf{Format}] \fbox{\textit{i64rem}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is \textit{value1} \% \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
				For two int64 values \(x\) and \(y\), the integer quotient \(q = x / y\) and remainder \(r = x \% y\) satisfy the following: \(x = q*y + r\)  and \(|r| < |y|\) \\ 
				 
				 \item [\textbf{Exception}] A run-time exception occurs when the divisor, \textit{value2}, is 0. 
			\end{labeling}		
			
		\newpage
		\subsection*{i64and}
			\addcontentsline{toc}{subsection}{i64and}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Bitwise AND on two int64s
				\item [\textbf{Format}] \fbox{\textit{i64and}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is calculated by taking the bitwise AND of \textit{value1} and \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
			
		\newpage
		\subsection*{i64or}
			\addcontentsline{toc}{subsection}{i64or}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Bitwise OR on two int64s
				\item [\textbf{Format}] \fbox{\textit{i64or}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is calculated by taking the bitwise OR of \textit{value1} and \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
			
		\newpage
		\subsection*{i64xor}
			\addcontentsline{toc}{subsection}{i64xor}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Bitwise XOR on two int64s
				\item [\textbf{Format}] \fbox{\textit{i64xor}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is calculated by taking the bitwise XOR of \textit{value1} and \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
			
		\newpage
		\subsection*{i64clear}
			\addcontentsline{toc}{subsection}{i64clear}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Bitwise clear (AND NOT) on two int64s
				\item [\textbf{Format}] \fbox{\textit{i64clear}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater } \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type int64. The values are popped off the operand stack. The int64 \textit{result} is calculated by taking the bit-complement of \textit{value2}, then applying \textit{value2} AND \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
				Bitwise clear is equivalent to (x \& (\textasciicircum y)), where \textasciicircum is the unary complement operator and \& is the bitwise AND operator. 
			\end{labeling}
			
		\newpage
		\subsection*{i64shl}
			\addcontentsline{toc}{subsection}{i64shl}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Left shift on an int64
				\item [\textbf{Format}] \fbox{\textit{i64shl}}
				\item [\textbf{Operand Stack}] TODO
				\item [\textbf{Description}] TODO: Left shift in Golang requires the right operand to be an unsigned integer
			\end{labeling}	
			
		\newpage
		\subsection*{i64shr}
			\addcontentsline{toc}{subsection}{i64shr}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Right shift on an int64
				\item [\textbf{Format}] \fbox{\textit{i64shr}}
				\item [\textbf{Operand Stack}] TODO
				\item [\textbf{Description}] TODO: Right shift in Golang requires the right operand to be an unsigned integer
			\end{labeling}	
			
		\newpage
		\subsection*{i64neg}
			\addcontentsline{toc}{subsection}{i64neg}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Negatation on an int64
				\item [\textbf{Format}] \fbox{\textit{i64neg}}
				\item [\textbf{Operand Stack}] \textit{..., value --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] \textit{value} must be of type int64. \textit{value} is popped off the operand stack. \textit{result} is the arithmetic negation of \textit{value}, -\textit{value}. \textit{result} is pushed onto the stack. \\ \\
				This operation is equivalent to 0 - \textit{value}. \\ \\
				An exception to this rule is if \textit{value} is the most negative integer that can be represented. Since signed integers are represented in two's complement, the positive value of the most negative number is not included. If \textit{value} is the most negative number possible for int64, then \textit{result} = \textit{value}.
			\end{labeling}	
			
		\newpage
		\subsection*{i64comp}
			\addcontentsline{toc}{subsection}{i64comp}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Bitwise complement on int64
				\item [\textbf{Format}] \fbox{\textit{i64comp}}
				\item [\textbf{Operand Stack}] \textit{..., value --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] \textit{value} must be of type int64. \textit{value} is popped off the operand stack. \textit{result} is the bitwise complement of all bits in \textit{result}. \textit{result} is pushed onto the stack. \\ \\
				
			\end{labeling}	
			
		\newpage
		\subsection*{if\_i64eq}
			\addcontentsline{toc}{subsection}{if\_i64eq}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if two int64s are equal 
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? With labels, like x86, or byte numbers as with Java, or some other way? 
			\end{labeling}	
			
		\newpage
		\subsection*{if\_i64ne}
			\addcontentsline{toc}{subsection}{if\_i64ne}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if two int64s are not equal
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as if\_i64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_i64lt}
			\addcontentsline{toc}{subsection}{if\_i64lt}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if int64 is less than other int64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as if\_i64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_i64le}
			\addcontentsline{toc}{subsection}{if\_i64le}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if int64 is less than or equal to other int64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as if\_i64eq
			\end{labeling}	
		\newpage
		\subsection*{if\_i64gt}
			\addcontentsline{toc}{subsection}{if\_i64gt}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if int64 is greater than other int64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as if\_i64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_i64ge}
			\addcontentsline{toc}{subsection}{if\_i64ge}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if int64 is greater than or equal to other int64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as if\_i64eq
			\end{labeling}	
		\newpage
		\subsection*{i64tof64}
			\addcontentsline{toc}{subsection}{i64tof64}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Convert int64 to float64
				\item [\textbf{Format}] \fbox{\textit{i64tof64}}
				\item [\textbf{Operand Stack}] \textit{..., value --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] \textit{value} must be of type int64. \textit{value} is popped off the operand stack. \textit{result} is the result of converting \textit{value} from an int64 to a float64. \textit{result} is pushed onto the stack. \\ \\
				The conversion may result in a loss of precision in \textit{result} due to the limited number of bits in the mantissa, as per the IEEE 754 standard. 
			\end{labeling}	
		\newpage
		
		\subsection*{i64toa}
			\addcontentsline{toc}{subsection}{i64toa}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Convert int64 to string
				\item [\textbf{Format}] \fbox{\textit{i64toa}}
				\item [\textbf{Operand Stack}] \textit{..., value --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] \textit{value} must be of type int64. \textit{value} is popped off the operand stack. \textit{result} is the result of converting \textit{value} from an int64 to a string. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
		\newpage
		
	\section{float64}
		\begin{itemize}
			\item f64add
			\item f64sub
			\item f64mul
			\item f64div
			\\ \hrule
			\item if\_f64eq
			\item if\_f64ne
			\item if\_f64lt
			\item if\_f64le
			\item if\_f64gt
			\item if\_f64ge
			\\ \hrule
			\item f64toi64
		\end{itemize}
		\newpage
		\subsection*{f64add}
			\addcontentsline{toc}{subsection}{f64add}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Add two float64s
				\item [\textbf{Format}] \fbox{\textit{f64add}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type float64. The values are popped off the operand stack. The float64 \textit{result} is calculated as the value of \textit{value1} + \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
		\newpage
		
		\subsection*{f64sub}
			\addcontentsline{toc}{subsection}{f64sub}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Subtract two float64s
				\item [\textbf{Format}] \fbox{\textit{f64sub}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type float64. The values are popped off the operand stack. The float64 \textit{result} is calculated as the value of \textit{value1} - \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
		\newpage
		
		\subsection*{f64mul}
			\addcontentsline{toc}{subsection}{f64mul}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Multiply two float64s
				\item [\textbf{Format}] \fbox{\textit{f64mul}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type float64. The values are popped off the operand stack. The float64 \textit{result} is calculated as the value of \textit{value1} * \textit{value2}. \textit{result} is pushed onto the stack. \\ \\
			\end{labeling}	
		\newpage
		
		\subsection*{f64div}
			\addcontentsline{toc}{subsection}{f64div}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Divide two float64s
				\item [\textbf{Format}] \fbox{\textit{f64div}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] Both \textit{value1} and \textit{value2} must be of type float64. The values are popped off the operand stack. The float64 \textit{result} is calculated as the value of \textit{value1} / \textit{value2}. \textit{result} is pushed onto the stack. \\ 
				\item [\textbf{Notes}] As of Golang 1.7, floating-point division by 0 does not raise a runtime exception. It returns positive infinity, +Inf.
			\end{labeling}	
		\newpage
		
		\subsection*{if\_f64eq}
			\addcontentsline{toc}{subsection}{if\_f64eq}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if two float64s are equal 
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? With labels, like x86, or byte numbers as with Java, or some other way? 
			\end{labeling}	
		\newpage
		
		\subsection*{if\_f64ne}
			\addcontentsline{toc}{subsection}{if\_f64ne}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if two float64s are not equal 
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as with if\_f64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_f64lt}
			\addcontentsline{toc}{subsection}{if\_f64lt}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if a float64 is less than other float64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as with if\_f64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_f64le}
			\addcontentsline{toc}{subsection}{if\_f64le}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if a float64 is less than or equal to other float64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as with if\_f64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_f64gt}
			\addcontentsline{toc}{subsection}{if\_f64gt}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if a float64 is greater than other float64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as with if\_f64eq
			\end{labeling}	
		\newpage
		
		\subsection*{if\_f64ge}
			\addcontentsline{toc}{subsection}{if\_f64ge}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Check if a float64 is greater than or equal other float64
				\item [\textbf{Format}] \fbox{\textit{TODO}}
				\item [\textbf{Operand Stack}] \textit{..., value1, value2 --\textgreater} \\
										\textit{..., }
				\item [\textbf{Description}] TODO: How to handle jumps? Same as with if\_f64eq
			\end{labeling}	
		\newpage
		\subsection*{f64toi64}
			\addcontentsline{toc}{subsection}{f64toi64}
			\begin{labeling}{Operand Stack Size}
				\item [\textbf{Operation}] Convert float64 to int64
				\item [\textbf{Format}] \fbox{\textit{f64toi64}}
				\item [\textbf{Operand Stack}] \textit{..., value --\textgreater} \\
										\textit{..., result}
				\item [\textbf{Description}] \textit{value} must be of type float64. \textit{value} is popped off the operand stack. \textit{result} is the result of converting \textit{value} from an float64 to a int64. \textit{result} is pushed onto the stack. \\ \\
				This conversion truncates towards 0 (fraction is discarded).  
			\end{labeling}	
		\newpage
	
	\section{string}
		\begin{itemize}
			\item strconcat
			\item ...comparisons...
		\end{itemize}
		TODO: How will strings be stored in bytecode? \\
		Most string conversions must be done with the \colorbox{code}{strconv} package. See \url{https://golang.org/pkg/strconv/}.
	

\end{document}